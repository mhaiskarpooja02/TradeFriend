# core/trade_manager.py
"""
TradeManager
------------
- Automatic broker initialization (Dhan, Angel, Motilal) — safe if any fail to init.
- Sync holdings from all brokers (merges into a single holdings.json).
- Update instruments.json based on holdings (sets target1/2, quantities).
- Monitor instruments during market hours (uses Angel getltp for price checks).
- Control flags via control/control.json (daily_refresh_enabled, force_refresh, last_refresh_date).

Usage:
    from core.trade_manager import TradeManager
    tm = TradeManager()           # will try to init all brokers
    tm.daily_refresh()            # run daily refresh (respects control flags & time)
    tm.monitor_targets()          # run monitoring (can be called periodically)
"""

import os
import json
import datetime
from typing import List, Dict, Any, Optional
from broker.angel_client import getltp

from config.settings import HOLDINGS_FILE, INSTRUMENTS_FILE
from utils.logger import get_logger
from utils.symbol_resolver import SymbolResolver

# Broker clients + market LTP helper (your existing modules)
# They may raise on import if not present or misconfigured; guard imports below.
logger = get_logger(__name__)

# Try imports — if they fail, we keep them None and handle gracefully
try:
    from broker.dhan_client import DhanClient
except Exception as e:
    DhanClient = None
    logger.debug(f"DhanClient import failed: {e}")

try:
    from broker.angel_client import AngelClient, getltp  # getltp used for LTP / market data
except Exception as e:
    AngelClient = None
    getltp = None
    logger.debug(f"AngelClient/getltp import failed: {e}")

try:
    from broker.motilal_client import MotilalClient
except Exception as e:
    MotilalClient = None
    logger.debug(f"MotilalClient import failed: {e}")


class TradeManager:
    TARGET1_PCT = 0.05   # +5%
    TARGET2_PCT = 0.10   # +10%
    CONTROL_FILE = os.path.join("control", "control.json")

    def __init__(self):
        # Initialize available brokers (best-effort)
        self.brokers = self._init_brokers()
        logger.info(f"Initialized brokers: {[type(b).__name__ for b in self.brokers]}")

        self.holdings: List[Dict[str, Any]] = self.load_json(HOLDINGS_FILE)
        self.instruments: List[Dict[str, Any]] = self.load_json(INSTRUMENTS_FILE)
        self.resolver = SymbolResolver()

    # -------------------- Broker init --------------------
    def _init_brokers(self) -> List[Any]:
        """Initialize broker clients that are importable / configured."""
        brokers = []
        if DhanClient is not None:
            try:
                brokers.append(DhanClient())
            except Exception as e:
                logger.warning(f"Failed to init DhanClient: {e}")
        if AngelClient is not None:
            try:
                brokers.append(AngelClient())
            except Exception as e:
                logger.warning(f"Failed to init AngelClient: {e}")
        if MotilalClient is not None:
            try:
                brokers.append(MotilalClient())
            except Exception as e:
                logger.warning(f"Failed to init MotilalClient: {e}")
        return brokers

    # -------------------- File helpers --------------------
    def load_json(self, file_path: str) -> List[Dict[str, Any]]:
        try:
            if os.path.exists(file_path):
                with open(file_path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    if isinstance(data, list):
                        return data
                    if isinstance(data, dict) and "data" in data:
                        return data["data"]
            return []
        except Exception as e:
            logger.error(f"Failed to load JSON {file_path}: {e}", exc_info=True)
            return []

    def save_json(self, data: List[Dict[str, Any]], file_path: str) -> None:
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=4, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Failed to save JSON {file_path}: {e}", exc_info=True)

    # -------------------- Control file helpers --------------------
    def load_control(self) -> Dict[str, Any]:
        try:
            logger.info("load_control is getting called")
            if os.path.exists(self.CONTROL_FILE):
                with open(self.CONTROL_FILE, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    if isinstance(data, dict):
                        return data
            return {}
        except Exception as e:
            logger.error(f"Failed to load control.json: {e}", exc_info=True)
            return {}

    def save_control(self, data: Dict[str, Any]) -> None:
        try:
            os.makedirs(os.path.dirname(self.CONTROL_FILE), exist_ok=True)
            tmp = self.CONTROL_FILE + ".tmp"
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=4)
            os.replace(tmp, self.CONTROL_FILE)
        except Exception as e:
            logger.error(f"Failed to save control.json: {e}", exc_info=True)

    # -------------------- Daily refresh --------------------
    def daily_refresh(self, force: bool = False) -> None:
        """
        Run once after market close (15:30) to sync holdings and update instruments.
        Controlled by control.json flags:
            - daily_refresh_enabled (bool)
            - force_refresh (bool)
        """
        logger.info("Daily refresh is getting called")
        control = self.load_control()
        daily_enabled = control.get("daily_refresh_enabled", True)
        force_refresh = control.get("force_refresh", False)

        if not daily_enabled and not force_refresh and not force:
            logger.info("Daily refresh disabled in control.json. Skipping.")
            return

        now = datetime.datetime.now() if hasattr(datetime, "datetime") else datetime.datetime.now()
        # Accept force or force_refresh as override to run anytime
        if not (force or force_refresh) and (now.hour < 15 or (now.hour == 15 and now.minute < 30)):
            logger.info("Market still open. Skipping daily refresh.")
            return

        logger.info("Running daily refresh after market close...")

        # Sync holdings across all brokers
        total_changes = self.sync_holdings_with_all_brokers()

        # Update instruments from the merged holdings
        if self.holdings:
            self.update_instruments(self.holdings)
        else:
            logger.warning("No holdings found after sync; instruments update skipped.")

        # update control flags
        control["last_refresh_date"] = now.strftime("%Y-%m-%d")
        control["force_refresh"] = False
        self.save_control(control)

        logger.info(f"Daily refresh done. Total holding changes: {total_changes}")

    # -------------------- Sync holdings --------------------
    def sync_holdings_with_all_brokers(self) -> int:
        """
        Sync holdings from each broker with per-broker logic.
        Dhan: refresh holdings + update instruments
        AngelOne / Motilal: placeholder for future development
        """
        logger.info("Syncing holdings from all brokers...")
    
        total_changes = 0
    
        for broker in self.brokers:
            broker_name = type(broker).__name__
            logger.info(f"Processing broker: {broker_name}")
    
            if broker_name == "DhanClient":
                # Step 1: Refresh holdings from Dhan
                try:
                    self.refresh_holdings(broker)  # pass broker explicitly
                    logger.info(f"Dhan holdings refreshed: {len(self.holdings)} items")
                except Exception as e:
                    logger.exception(f"Failed to refresh Dhan holdings: {e}")
                    continue
                
                # Step 2: Update instruments.json with new targets
                if self.holdings:
                    try:
                        changes = self.update_instruments(self.holdings)
                        total_changes += changes
                        logger.info(f"Dhan instruments updated: {changes} changes applied")
                    except Exception as e:
                        logger.exception(f"Failed to update instruments for Dhan: {e}")
                else:
                    logger.warning("No holdings found from Dhan for instrument update")
    
            elif broker_name == "AngelClient":
                # Placeholder for AngelOne logic
                logger.info("AngelOne integration placeholder — will be developed in future")
    
            elif broker_name == "MotilalClient":
                # Placeholder for Motilal logic
                logger.info("Motilal integration placeholder — will be developed in future")
    
            else:
                logger.warning(f"Unknown broker type: {broker_name} — skipping")
    
        logger.info(f"Total holdings changes processed: {total_changes}")
        return total_changes

    # -------------------- Instruments update --------------------
    def refresh_holdings(self, broker) -> int:
        """
        Fetch holdings from broker and overwrite holdings.json.
        Returns: Number of holdings loaded.
        """
        logger.info(f"Refreshing holdings from broker: {type(broker).__name__}")
        try:
            api_holdings = broker.get_holdings() or []
        except Exception as e:
            logger.error(f"Failed to fetch holdings from broker: {e}", exc_info=True)
            return 0
    
        self.holdings = api_holdings
        self.save_json(self.holdings, HOLDINGS_FILE)
        logger.info(f"Holdings refreshed: {len(api_holdings)} records loaded.")
        return len(api_holdings)
    
    # -------------------- Instruments update --------------------
    def update_instruments(self, new_holdings: List[Dict[str, Any]]) -> int:
        """
        Update instruments.json based on holdings.
        - Preserves user-set targets if available.
        - Calculates monitor_active dynamically:
            * False if LTP < avg_price
            * True if LTP between avg_price and target2 + buffer
            * False if LTP >= target2 + buffer
        - Adds new instruments, updates existing, removes stale ones.
        """
        if not new_holdings:
            logger.info("No holdings provided for instruments update.")
            return 0

        buffer_pct = 0.02  # 2% buffer for monitoring

        instruments = self.load_json(INSTRUMENTS_FILE)
        instruments_map = {str(i.get("securityId")): i for i in instruments if i.get("securityId")}
        holding_ids = {str(h.get("securityId")) for h in new_holdings if h.get("securityId")}

        added_count = 0
        updated_count = 0

        for h in new_holdings:
            sid = str(h.get("securityId"))
            if not sid:
                continue

            symbol = h.get("tradingSymbol") or h.get("symbol") or ""
            qty = int(h.get("totalQty") or h.get("dpQty") or h.get("quantity") or 0)
            avg_price = float(h.get("avgCostPrice") or h.get("avg_price") or 0.0)

            # Resolve symbol and fetch LTP
            ltp = None
            resolved = self.resolver.resolve_symbol(symbol)
            if resolved:
                try:
                    ltp = getltp(resolved)
                    logger.info(f"LTP for {symbol}: {ltp}")
                except Exception as e:
                    logger.warning(f"Failed to fetch LTP for {symbol}: {e}")
                    ltp = None

            base_price = ltp or avg_price

            # Preserve user-set targets if they exist
            existing_instrument = instruments_map.get(sid, {})
            t1 = existing_instrument.get("target1") or round(base_price * (1 + self.TARGET1_PCT), 2)
            t2 = existing_instrument.get("target2") or round(base_price * (1 + self.TARGET2_PCT), 2)
            broker = existing_instrument.get("broker") or "DHAN"
            sell_qty1 = qty // 2
            sell_qty2 = qty - sell_qty1

            # Determine monitor_active dynamically
            if ltp is None:
                monitor_active = True
            elif ltp < avg_price:
                monitor_active = False
            elif ltp >= t2 * (1 + buffer_pct):
                monitor_active = False
            else:
                monitor_active = True

            instrument_data = {
                "symbol": symbol,
                "securityId": sid,
                "quantity": qty,
                "avg_price": avg_price,
                "ltp": ltp,
                "last_close": base_price,
                "target1": t1,
                "target2": t2,
                "sell_qty_target1": sell_qty1,
                "sell_qty_target2": sell_qty2,
                "monitor_active": monitor_active,
                "broker":broker
            }

            if sid in instruments_map:
                instruments_map[sid].update(instrument_data)
                updated_count += 1
                logger.info(f"Updated instrument {symbol} (sid={sid}) LTP={ltp}, targets {t1}, {t2}, monitor_active={monitor_active}")
            else:
                instruments_map[sid] = instrument_data
                added_count += 1
                logger.info(f"Added instrument {symbol} (sid={sid}) LTP={ltp}, targets {t1}, {t2}, monitor_active={monitor_active}")

        # Remove stale instruments
        stale_sids = set(instruments_map.keys()) - holding_ids
        for stale_sid in stale_sids:
            logger.info(f"Removing stale instrument with securityId={stale_sid}")
            instruments_map.pop(stale_sid, None)

        # Save updated instruments
        self.instruments = list(instruments_map.values())
        self.save_json(self.instruments, INSTRUMENTS_FILE)
        logger.info(f"Instruments update completed: {added_count} added, {updated_count} updated, {len(stale_sids)} removed")

        return added_count + updated_count + len(stale_sids)



    # -------------------- Monitoring --------------------
    def monitor_targets(self) -> None:
        """
        Load instruments.json and check LTP for each.
        If target hit, try to place order using any available broker (first successful).
        """
        self.instruments = self.load_json(INSTRUMENTS_FILE)
        if not self.instruments:
            logger.warning("No instruments to monitor.")
            return

        if getltp is None:
            logger.warning("getltp() is not available (Angel client import failed). Monitoring skipped.")
            return

        updated = False

        for instrument in self.instruments:
            try:
                symbol = instrument.get("symbol")
                sid = instrument.get("securityId")
                avg_price = float(instrument.get("avg_price", 0))
                if not sid or not symbol:
                    continue

                resolved = self.resolver.resolve_symbol(symbol)
                if not resolved:
                    logger.debug(f"No resolver entry for {symbol}, skipping.")
                    continue

                # Use Angel's getltp (fast) — returns numeric LTP or None
                ltp = None
                try:
                    ltp = getltp(resolved)
                except Exception as e:
                    logger.debug(f"getltp error for {symbol}: {e}")

                # If no LTP from Angel, fall back to last_close from instruments or holdings
                if ltp is None:
                    ltp = instrument.get("last_close") or instrument.get("lastTradedPrice") or 0

                # If still no meaningful price, skip
                if ltp is None or ltp == 0:
                    continue

                

                # Target1
                if instrument.get("target1") and instrument.get("sell_qty_target1", 0) > 0:
                    if ltp >= instrument["target1"]:
                        qty = instrument["sell_qty_target1"]
                        placed = self._attempt_place_order(sid, qty)
                        if placed:
                            instrument["sell_qty_target1"] = 0
                            updated = True
                            logger.info(f"{symbol} hit Target1 {instrument['target1']} (LTP={ltp})")

                # Target2
                if instrument.get("target2") and instrument.get("sell_qty_target2", 0) > 0:
                    if ltp >= instrument["target2"]:
                        qty = instrument["sell_qty_target2"]
                        placed = self._attempt_place_order(sid, qty)
                        if placed:
                            instrument["sell_qty_target2"] = 0
                            updated = True
                            logger.info(f"{symbol} hit Target2 {instrument['target2']} (LTP={ltp})")

            except Exception as e:
                logger.error(f"Error monitoring {instrument}: {e}", exc_info=True)

        if updated:
            self.save_json(self.instruments, INSTRUMENTS_FILE)
            logger.info("instruments.json updated after trades.")

    def _attempt_place_order(self, security_id: str, qty: int, preferred_broker: str = None) -> bool:
        """
        Try placing order via configured brokers in order.
        If preferred_broker is given, restrict to that one.
        Returns True if any broker reports success-like response.
        """
        brokers_to_try = self.brokers
    
        # If a broker is specified (e.g., "DHAN"), filter
        if preferred_broker:
            brokers_to_try = [b for b in self.brokers if type(b).__name__.upper().startswith(preferred_broker.upper())]
    
            if not brokers_to_try:
                logger.warning(f"Preferred broker {preferred_broker} not initialized, falling back to all.")
                brokers_to_try = self.brokers
    
        for broker in brokers_to_try:
            try:
                if not hasattr(broker, "place_order"):
                    continue
                
                try:
                    res = broker.place_order(security_id=security_id, qty=qty)
                except TypeError:
                    try:
                        res = broker.place_order(security_id, qty)
                    except Exception as e:
                        logger.debug(f"place_order call failed for {type(broker).__name__}: {e}")
                        res = None
    
                if res:
                    logger.info(f"Order placed via {type(broker).__name__} for sid={security_id} qty={qty}")
                    return True
            except Exception as e:
                logger.exception(f"Error placing order with {type(broker).__name__}: {e}")
    
        logger.warning(f"Failed to place order for {security_id} qty={qty} on all brokers.")
        return False
    